"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Time = void 0;
const dockerClient_1 = require("./dockerClient");
const utils_1 = require("./utils");
class Time {
    static timeAdjustDelaySecond = 5;
    chain;
    timeAdded;
    constructor(chain) {
        this.chain = chain;
        this.timeAdded = 0;
    }
    async increase(time, fromBlockTime = "") {
        if (time < 0) {
            throw new Error("adding time much be greater than zero");
        }
        const { elapsedBlocks, startingBlock } = await this.chain.waitTillNextBlock(2);
        const startTime = (0, utils_1.blockTimeToMs)(startingBlock.head_block_time);
        let addingTime;
        let fromBlockTimeMs = startTime;
        if (fromBlockTime) {
            fromBlockTimeMs = (0, utils_1.blockTimeToMs)(fromBlockTime);
            addingTime = Math.floor(Math.max(0, time - (startTime - fromBlockTimeMs) / 1000 - elapsedBlocks * 0.5));
        }
        else {
            addingTime = Math.floor(Math.max(0, time - elapsedBlocks * 0.5));
        }
        if (addingTime === 0) {
            return 0;
        }
        let tries = 0;
        const maxTries = 15;
        do {
            if (tries >= maxTries) {
                throw new Error(`Exceeded ${maxTries} tries to change the blockchain time. Test cannot proceed.`);
            }
            await (0, dockerClient_1.manipulateChainTime)(this.chain.port, `+${this.timeAdded + addingTime}`);
            tries++;
            await (0, utils_1.sleep)(1000);
        } while (!(await this.chain.isProducingBlock()));
        await this.chain.waitTillNextBlock(2);
        this.timeAdded += addingTime;
        const endTime = (0, utils_1.blockTimeToMs)((await this.chain.getInfo()).head_block_time);
        return endTime - fromBlockTimeMs;
    }
    async increaseTo(time) {
        const currentHeadBlockTime = (0, utils_1.blockTimeToMs)((await this.chain.getInfo()).head_block_time);
        if (time < currentHeadBlockTime) {
            throw new Error(`time must be greater than current block time`);
        }
        await this.chain.waitTillNextBlock(2);
        const headBlockTimeAfterResolvePendingTransaction = (0, utils_1.blockTimeToMs)((await this.chain.getInfo()).head_block_time);
        if (time < headBlockTimeAfterResolvePendingTransaction) {
            return headBlockTimeAfterResolvePendingTransaction;
        }
        const addingTime = Math.ceil((time - headBlockTimeAfterResolvePendingTransaction) / 1000);
        let tries = 0;
        const maxTries = 15;
        do {
            if (tries >= maxTries) {
                throw new Error(`Exceeded ${maxTries} tries to change the blockchain time. Test cannot proceed.`);
            }
            await (0, dockerClient_1.manipulateChainTime)(this.chain.port, `+${this.timeAdded + addingTime}`);
            tries++;
            await (0, utils_1.sleep)(1000);
        } while (!(await this.chain.isProducingBlock()));
        await this.chain.waitTillNextBlock(2);
        this.timeAdded += addingTime;
        return (0, utils_1.blockTimeToMs)((await this.chain.getInfo()).head_block_time);
    }
}
exports.Time = Time;
//# sourceMappingURL=time.js.map