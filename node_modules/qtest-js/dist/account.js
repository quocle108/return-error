"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Account = void 0;
const tslib_1 = require("tslib");
const fs_1 = tslib_1.__importDefault(require("fs"));
const eosjs_serialize_1 = require("eosjs/dist/eosjs-serialize");
const asset_1 = require("./asset");
const contract_1 = require("./contract");
const utils_1 = require("./utils");
class Account {
    name;
    chain;
    contract;
    constructor(chain, name) {
        this.chain = chain;
        this.name = name;
    }
    async updateAuth(permission, parent, threshold, keys, accounts, waits = []) {
        return this.chain.api.transact({
            actions: [
                {
                    account: "eosio",
                    name: "updateauth",
                    authorization: [
                        {
                            actor: this.name,
                            permission: "owner",
                        },
                    ],
                    data: {
                        account: this.name,
                        permission,
                        parent,
                        auth: {
                            threshold,
                            keys,
                            accounts,
                            waits,
                        },
                    },
                },
            ],
        }, (0, utils_1.generateTapos)());
    }
    async getInfo() {
        return await this.chain.rpc.get_account(this.name);
    }
    async getBalance() {
        const currencyBalance = await this.chain.rpc.get_currency_balance("eosio.token", this.name, this.chain.coreSymbol.symbol);
        return asset_1.Asset.fromString(currencyBalance[0]);
    }
    async addAuth(permission, parent) {
        const accountInfo = await this.getInfo();
        const activePermission = accountInfo.permissions.find((p) => p.perm_name === "active");
        return this.chain.api.transact({
            actions: [
                {
                    account: "eosio",
                    name: "updateauth",
                    authorization: [
                        {
                            actor: this.name,
                            permission: "owner",
                        },
                    ],
                    data: {
                        account: this.name,
                        permission,
                        parent,
                        auth: {
                            threshold: activePermission.required_auth.threshold,
                            keys: activePermission.required_auth.keys,
                            accounts: activePermission.required_auth.accounts,
                            waits: activePermission.required_auth.waits,
                        },
                    },
                },
            ],
        }, (0, utils_1.generateTapos)());
    }
    async linkAuth(code, type, permission) {
        return this.chain.api.transact({
            actions: [
                {
                    account: "eosio",
                    name: "linkauth",
                    authorization: [
                        {
                            actor: this.name,
                            permission: "owner",
                        },
                    ],
                    data: {
                        account: this.name,
                        code,
                        type,
                        requirement: permission,
                    },
                },
            ],
        }, (0, utils_1.generateTapos)());
    }
    async addCode(permission) {
        const accountInfo = await this.getInfo();
        const updatingPermission = accountInfo.permissions.find((p) => p.perm_name === permission);
        let accountPermission = [];
        if (updatingPermission) {
            const codePermission = updatingPermission.required_auth.accounts.find((a) => a.permission.actor === this.name &&
                a.permission.permission === "eosio.code");
            if (codePermission) {
                throw new Error("Already set code for this account");
            }
            accountPermission = accountPermission.concat(updatingPermission.required_auth.accounts);
            accountPermission.push({
                permission: {
                    actor: this.name,
                    permission: "eosio.code",
                },
                weight: updatingPermission.required_auth.threshold,
            });
        }
        else {
            accountPermission.push({
                permission: {
                    actor: this.name,
                    permission: "eosio.code",
                },
                weight: 1,
            });
        }
        return this.chain.api.transact({
            actions: [
                {
                    account: "eosio",
                    name: "updateauth",
                    authorization: [
                        {
                            actor: this.name,
                            permission: "owner",
                        },
                    ],
                    data: {
                        account: this.name,
                        permission,
                        parent: updatingPermission ? updatingPermission.parent : "active",
                        auth: {
                            threshold: updatingPermission
                                ? updatingPermission.required_auth.threshold
                                : 1,
                            keys: updatingPermission
                                ? updatingPermission.required_auth.keys
                                : [],
                            accounts: accountPermission,
                            waits: updatingPermission
                                ? updatingPermission.required_auth.waits
                                : [],
                        },
                    },
                },
            ],
        }, (0, utils_1.generateTapos)());
    }
    async transfer(to, quantity, memo = "") {
        return this.chain.api.transact({
            actions: [
                {
                    account: "eosio.token",
                    name: "transfer",
                    authorization: [
                        {
                            actor: this.name,
                            permission: "active",
                        },
                    ],
                    data: {
                        from: this.name,
                        to,
                        quantity,
                        memo,
                    },
                },
            ],
        }, (0, utils_1.generateTapos)());
    }
    async setContract(contractPath) {
        if (!fs_1.default.existsSync(contractPath.abi) || !fs_1.default.existsSync(contractPath.wasm)) {
            throw new Error("can not find abi or wasm file of contract " +
                JSON.stringify(contractPath, null, 2));
        }
        const buffer = new eosjs_serialize_1.SerialBuffer({
            textEncoder: this.chain.api.textEncoder,
            textDecoder: this.chain.api.textDecoder,
        });
        let abiJSON = JSON.parse(fs_1.default.readFileSync(contractPath.abi, "utf8"));
        const abiDefinitions = this.chain.api.abiTypes.get("abi_def");
        abiJSON = abiDefinitions.fields.reduce((acc, { name: fieldName }) => Object.assign(acc, { [fieldName]: acc[fieldName] || [] }), abiJSON);
        abiDefinitions.serialize(buffer, abiJSON);
        const serializedAbiHexString = Buffer.from(buffer.asUint8Array()).toString("hex");
        const wasmHexString = fs_1.default.readFileSync(contractPath.wasm).toString("hex");
        const tx = await this.chain.api.transact({
            actions: [
                {
                    account: "eosio",
                    name: "setcode",
                    authorization: [
                        {
                            actor: this.name,
                            permission: "active",
                        },
                    ],
                    data: {
                        account: this.name,
                        vmtype: 0,
                        vmversion: 0,
                        code: wasmHexString,
                    },
                },
                {
                    account: "eosio",
                    name: "setabi",
                    authorization: [
                        {
                            actor: this.name,
                            permission: "active",
                        },
                    ],
                    data: {
                        account: this.name,
                        abi: serializedAbiHexString,
                    },
                },
            ],
        }, (0, utils_1.generateTapos)());
        this.contract = new contract_1.Contract(this, wasmHexString, abiJSON);
        return this.contract;
    }
    async loadContract() {
        const getCodeResult = await this.chain.rpc.get_code(this.name);
        if (getCodeResult.code_hash ===
            "0000000000000000000000000000000000000000000000000000000000000000") {
            throw new Error(`Account ${this.name} contract_code does not exist`);
        }
        if (!getCodeResult.abi) {
            throw new Error(`Account ${this.name} contract_abi does not exist`);
        }
        this.contract = new contract_1.Contract(this, Buffer.from(getCodeResult.wasm).toString("hex"), getCodeResult.abi);
        return this.contract;
    }
}
exports.Account = Account;
//# sourceMappingURL=account.js.map