"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Chain = void 0;
const tslib_1 = require("tslib");
const node_fetch_1 = tslib_1.__importDefault(require("node-fetch"));
const eosjs_1 = require("eosjs");
const dockerClient_1 = require("./dockerClient");
const utils_1 = require("./utils");
const wallet_1 = require("./wallet");
const asset_1 = require("./asset");
const time_1 = require("./time");
const system_1 = require("./system");
const utils_2 = require("./utils");
class Chain {
    coreSymbol;
    tokenSupply;
    api;
    rpc;
    accounts;
    port;
    systemContractEnable;
    time;
    system;
    constructor(rpc, api, port, tokenSymbol) {
        this.port = port;
        this.rpc = rpc;
        this.api = api;
        const tokenDecimal = this.getChainTokenDecimal(tokenSymbol);
        this.coreSymbol = new asset_1.Symbol(tokenDecimal, tokenSymbol);
        this.systemContractEnable = true;
        this.time = new time_1.Time(this);
        this.system = new system_1.System(this);
    }
    static validateChainName(chainName) {
        const validChainNames = ["WAX", "EOS", "TLOS"];
        if (!validChainNames.includes(chainName)) {
            throw new Error("Chain name is not valid: " +
                chainName +
                ". Should be one of " +
                JSON.stringify(validChainNames));
        }
    }
    static async setupChain(chainName) {
        Chain.validateChainName(chainName);
        const port = Math.floor(Math.random() * 9900 + 100);
        await (0, dockerClient_1.startChainContainer)(port, chainName);
        const rpc = new eosjs_1.JsonRpc(`http://127.0.0.1:${port}`, { fetch: node_fetch_1.default });
        const api = new eosjs_1.Api({
            rpc,
            signatureProvider: wallet_1.signatureProvider,
            textDecoder: new TextDecoder(),
            textEncoder: new TextEncoder(),
        });
        const newChain = new Chain(rpc, api, port, chainName);
        await newChain.waitForChainStart();
        await newChain.initializeTestAccounts();
        return newChain;
    }
    async clear() {
        await (0, dockerClient_1.killExistingChainContainer)(this.port);
    }
    async getInfo() {
        return await this.rpc.get_info();
    }
    async headBlockNum() {
        return +(await this.getInfo()).head_block_num;
    }
    async isNodeStartUp() {
        try {
            await this.getInfo();
            return true;
        }
        catch (e) {
            await (0, utils_1.sleep)(100);
            return false;
        }
    }
    async isProducingBlock() {
        try {
            const currentHeadBlock = await this.headBlockNum();
            await (0, utils_1.sleep)(500);
            return Number(await this.headBlockNum()) - Number(currentHeadBlock) > 0;
        }
        catch (e) {
            return false;
        }
    }
    async pushAction(action, broadcast = true, sign = true, tapos = {}) {
        tapos =
            JSON.stringify(tapos) === JSON.stringify({}) ? (0, utils_2.generateTapos)() : tapos;
        return this.api.transact({ actions: [action] }, { broadcast, sign, ...tapos });
    }
    async pushActions(actions, broadcast = true, sign = true, tapos = {}) {
        tapos =
            JSON.stringify(tapos) === JSON.stringify({}) ? (0, utils_2.generateTapos)() : tapos;
        return this.api.transact({ actions }, { broadcast, sign, ...tapos });
    }
    async waitTillNextBlock(numBlocks = 1) {
        const startingBlock = await this.getInfo();
        const currentBlockHeight = await this.waitTillBlock(startingBlock.head_block_num + numBlocks);
        return {
            startingBlock,
            elapsedBlocks: currentBlockHeight - Number(startingBlock.head_block_num),
        };
    }
    async waitTillBlock(target) {
        let currentBlockHeight = await this.headBlockNum();
        while (currentBlockHeight < target) {
            await (0, utils_1.sleep)(500);
            currentBlockHeight = await this.headBlockNum();
        }
        return currentBlockHeight;
    }
    async initializeTestAccounts() {
        this.accounts = await this.createTestAccounts(10);
    }
    async createTestAccounts(length) {
        const testAccountNames = [];
        for (let i = 0; i < length; i++) {
            testAccountNames.push(`acc${Math.floor(i / 5) + 1}${Math.floor(i % 5) + 1}.test`);
        }
        return this.system.createAccounts(testAccountNames);
    }
    async waitForChainStart() {
        let retryCount = 0;
        while (!(await (0, dockerClient_1.checkContainerHealthStatus)(this.port))) {
            await (0, utils_1.sleep)(100);
            if (retryCount === 100) {
                throw new Error("Docker container is not healthy");
            }
            retryCount++;
        }
        retryCount = 0;
        while (!(await this.isProducingBlock())) {
            if (retryCount === 20) {
                throw new Error("Cannot get chain status");
            }
            retryCount++;
        }
    }
    getChainTokenDecimal(chainName) {
        switch (chainName) {
            case "WAX":
                return 8;
            case "EOS":
            case "TLOS":
                return 4;
            default:
                throw new Error("can not find token decimal for chain name " + chainName);
        }
    }
}
exports.Chain = Chain;
//# sourceMappingURL=chain.js.map