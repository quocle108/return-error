"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getChainIp = exports.killAllExistingChainContainer = exports.killExistingChainContainer = exports.checkContainerHealthStatus = exports.getContainers = exports.manipulateChainTime = exports.startChainContainer = void 0;
const child_process_1 = require("child_process");
const dockerImageName = "genereos/qtest:v1.1.4";
function execute(command, ignoreFail = false) {
    try {
        return (0, child_process_1.execSync)(command, {
            encoding: "utf8",
        });
    }
    catch (e) {
        if (!ignoreFail) {
            throw e;
        }
        return "";
    }
}
const pullDockerImage = async () => {
    try {
        execute(`docker inspect --type=image ${dockerImageName}`);
    }
    catch (e) {
        if (e.toString().includes(`Error: No such image: ${dockerImageName}`)) {
            process.stdout.write(`Pulling docker image ${dockerImageName}. This process will take few mintutes ...\n`);
            process.stdout.write(`\x1b[93mWarning: Your tests might be failed for the first time while downloading the ${dockerImageName} because of the test timeout\x1b[39m\n`);
            execute(`docker pull ${dockerImageName}`);
        }
        else {
            throw e;
        }
    }
};
const startChainContainer = async (rpcPort = 8880, tokenSymbol = "EOS") => {
    const name = "qtest" + rpcPort;
    await pullDockerImage();
    execute(`docker run --name ${name} --env SYSTEM_TOKEN_SYMBOL='${tokenSymbol}' -d -p ${rpcPort}:8888 ${dockerImageName}`);
};
exports.startChainContainer = startChainContainer;
const manipulateChainTime = async (rpcPort, timeFormat) => {
    const name = "qtest" + rpcPort;
    execute(`docker exec ${name} /app/scripts/manipulate_time.sh "${timeFormat}"`);
};
exports.manipulateChainTime = manipulateChainTime;
const getContainers = () => {
    const rawResult = execute('docker ps -a --format "{{.Names}}:{{.ID}}"');
    const rawResultSplit = rawResult.split("\n");
    rawResultSplit.pop();
    return rawResultSplit.map((line) => {
        const lineSplit = line.split(":");
        return {
            name: lineSplit[0],
            id: lineSplit[1],
        };
    });
};
exports.getContainers = getContainers;
const checkContainerHealthStatus = async (rpcPort) => {
    const name = "qtest" + rpcPort;
    const rawResult = execute(`docker inspect --format='{{json .State.Health}}' ${name}`);
    const jsonResult = JSON.parse(rawResult);
    if (jsonResult.Status === "healthy") {
        return true;
    }
    else {
        return false;
    }
};
exports.checkContainerHealthStatus = checkContainerHealthStatus;
const killExistingChainContainer = async (rpcPort) => {
    const name = "qtest" + rpcPort;
    execute(`docker rm -f ${name}`);
};
exports.killExistingChainContainer = killExistingChainContainer;
const killAllExistingChainContainer = async () => {
    const containers = (0, exports.getContainers)();
    const qTestContainer = containers.find((c) => c.name.startsWith("qtest"));
    if (qTestContainer) {
        execute(`docker rm -f ${qTestContainer.id}`);
    }
};
exports.killAllExistingChainContainer = killAllExistingChainContainer;
const getChainIp = async (rpcPort) => {
    const name = "qtest" + rpcPort;
    return execute(`docker inspect -f '{{range .NetworkSettings.Networks}}{{.IPAddress}}{{end}}' ${name}`);
};
exports.getChainIp = getChainIp;
//# sourceMappingURL=dockerClient.js.map